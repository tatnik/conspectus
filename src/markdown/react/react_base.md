# Базовые понятия

## JSX

\- это синтаксическое расширение _JS_, позволяющее писать _HTML_-разметку внутри _JS_

- в **JSX** можно использовать:

  - тэги _HTML_
  - вложенные тэги
  - интерполяции (вставки любых корректных _JavaScript_-выражений внутри фигурных скобок)

- если тег пуст, то его можно сразу же закрыть с помощью />

- **JSX** можно:

  - использовать внутри инструкций if и циклов for
  - присваивать переменным
  - передавать функции в качестве аргумента и возвращать из функции

- **JSX** предотвращает атаки, основанные на инъекции кода (_XSS_), т.к. _React DOM_ экранирует все значения, включённые в JSX перед тем как отрендерить их

```jsx
const element = <h1 className="greeting">Привет, мир!</h1>;
```

- после компиляции JSX превращается в объект примерно такого вида:

```jsx
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Привет, мир!',
  },
};
```

**особености JSX**:

- атрибут _style_ в качестве значения принимает объект javascript
- в наименованиях используется _camel-case_, т.о. _font-family_ заменяется на _fontFamily_, _tabindex_ - на _tabIndex_
- _class_ заменяется на _className_, _for_ заменяется на _htmlFor_,

```jsx
const element = (
  <span className={userClassName} style={{color:"red", fontFamily:"Verdana"}}>
    Привет, {user}!
  <span>
)
```

## React

\- это _JavaScript_-библиотека с открытым исходным кодом для разработки пользовательских интерфейсов [Википедия...](https://ru.wikipedia.org/wiki/React)

- чаще всего используется для создания одностраничных приложений (_SPA - single page application_), где требуется быстрый и интерактивный пользовательский интерфейс.

- одна из ключевых особенностей _React_ - **компонентная архитектура**: пользовательский интерфейс разделен на несколько компонентов, каждый из которых отвечает за рендеринг части пользовательского интерфейса

- в **React** используется однонаправленная передача данных: cвойства передаются от родительских компонентов к дочерним. Компоненты получают свойства как множество неизменяемых значений, поэтому компонент не может напрямую изменять свойства, но может вызывать изменения через callback-функции. Такой механизм называют _свойства вниз, события наверх_

[Почему React не реактивен?](https://dev.to/balaevarif/pochiemu-react-nie-rieaktivien-40ig)

## React-компоненты

**Компонент**- независимая и переиспользуемая часть интерфейса, может содержать в себе как структуру (HTML-элементы), так и логику.

- компонетны могут ссылаться на другие компоненты
- имена компонентов должны начинаться с заглавной буквы

**Классовый компонент** - класс, который наследуется от _React.Component_, может содержать состояние (_state_), методы жизненного цикла и метод _render_, возвращающий _jsx_-разметку

- \+ прямой доступ к методам жизненного цикла
- \+ можно использовать классовые свойства для хранения данных без необходимости использования _this.setState_
- \+? есть наследование
- \- _State_ может быть только один
- \- надо не забывать писать _this_
- \- в целом больше кода

**Функциональный компонент** - функция, принимающая входные данные (_props_) и возвращающая _JSX_, определяющий структуру компонента.

- \+ компактный код, проще для понимания
- \+ код более декларативный и легче читается
- \+ их проще тестировать (не требуют создания экземпляров класса)
- \+ можно делать много _State_-ов
- \+ можно пользоваться хуками, в т.ч. самописными
- \+ проект, полностью написанный на хуках, имеет менее глубокое дерево компонентов
- \- весь код внутри одной функции

[Еще немного про классовые и функциональные компоненты...](https://habr.com/ru/companies/ruvds/articles/444348/)

- **Презентационный компонент** (тупой компонент, dumb component)
  используется для получения данных и их отображения на странице

```js
import React from 'react';

function Button(props) {
  return <button>{props.label}</button>;
}
```

- **Компонент-контейнер** заботится о том, как все работает.

  - может содержать логику для выборки данных, обработки пользовательского ввода и выполнения других задач

  - знает о состоянии и действиях приложения

  - передает данные и обратные вызовы презентационным компонентам через пропсы

```js
import React, { Component } from 'react';
import Button from './Button';

class Form extends Component {
  state = {
    name: '',
  };

  handleChange = (event) => {
    this.setState({ name: event.target.value });
  };

  handleSubmit = (event) => {
    event.preventDefault();
    // отправка формы
  };

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input
            type="text"
            value={this.state.name}
            onChange={this.handleChange}
          />
        </label>
        <Button label="Submit" />
      </form>
    );
  }
}
```

- **Управляемый компонент** получает все свои данные в качестве реквизита и передает изменения своему родительскому компоненту через обратные вызовы

- **Неуправляемый компонент** сам управляет своим собственным состоянием внутри себя

## Чистая функция

\- это функция, которая не меняет свои входные данные и предсказуемо возвращает один и тот же результат для одинаковых аргументов

```js
function sum(a, b) {
  return a + b;
}
```

## Props (сокр. от "propetries")

- объект _props_ предоставляет интерфейс для передачи данных от родительского компонента к дочернему и позволяет динамически настраивать компоненты
- пропсы передаются компоненту в виде атрибутов и становятся доступными внутри компонента как свойства
- являются неизменяемыми (_React_-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам)
- им можно задавать значения по умолчанию

## State (состояние)

- это специальный объект внутри компонента для хранения и отслеживания изменяющихся данных

- _state_ доступен только для самого компонента и скрыт от других

- он позволяет компоненту запоминать данные и перерисовывать себя, когда эти данные меняются

- каждый компонент имеет собственный _state_, что позволяет изолировать данные и логику между компонентами

- _state_ инициализируется в конструкторе компонента (в классовых компонентах) или с помощью хука _UseState_ (в функциональных)

- _state_ изменяется методом _setState_ (в классовых компонентах) или функцией, возвращаемой _UseState_ (в функциональных)

- изменения стейта происходят асинхронно, React может объединять несколько обновлений стейта для оптимизации производительности

- рекомендуется не изменять состояние напрямую, а создавать новый объект _state_ с обновленными данными, что упрощает отслеживание изменений

- _state_ может быть передан дочерним компонентам через пропсы

## Жизненный цикл компонента

- монтирование (_mounting_) - первоначальный рендеринг компонента в _DOM_

- обновление (_updating_) - компонент повторно визуализируетсят при изменении его свойств или состояний

- размонтирование (_unmounting_) - удаление компонента из _DOM_

## Методы жизненного цикла в классовых компонентах

- **_монтирование_**

  1. **constructor(props)** начальная инициализация компонента

  2. **getDerivedStateFromProps(nextProps,prevState)** вызывается непосредственно перед методом рендеринга
     - nextProps \— объект, представляющий новые реквизиты, которые получает компонент
     - prevState \— объект, представляющий текущее состояние компонента

  - метод должен возвращать объект для обновления состояния или значение null, чтобы указать, что новые свойства не требуют каких-либо обновлений состояния
  - это статический метод, а это значит, что у него нет доступа к экземпляру компонента, поэтому нельзя использовать this внутри getDerivedStateFromProps
  - он не запускает повторную отрисовку, но позволяет обновлять состояние на основе изменений в реквизитах
  - обновленное состояние будет использоваться при следующем рендеринге
    [Подробнее...](https://www.dhiwise.com/post/best-practices-for-using-getderivedstatefromprops-in-your-react-applications)

  3. **render()** рендеринг компонента

  4. **componentDidMount** вызывается после рендеринга компонента, здесь можно выполнять настройки, для которых необходим DOM, отправлять запросы к удаленным ресурам, настроить прослушиватели событий и т. д.

- **_обновление_**

  1. **getDerivedStateFromProps(_nextProps,prevState_)**

  2. **shouldComponentUpdate(_nextProps, nextState_)** вызывается каждый раз при обновлении объекта props или state

  - _nextProps, nextState_ \- новые объекты
  - метод должен возвращать логическое значение, и на его основе будет определяться, будет ли компонент перерисован или нет

  3. **render()** рендеринг компонента, если на предыдущем шаге было получено _true_

  4. **getSnapshotBeforeUpdate(_prevProps, prevState_)** позволяет компоненту получить информацию из DOM перед возможным обновлением. Возвращает в качестве значения какой-то отдельный аспект, который передается в качестве третьего параметра в метод _componentDidUpdate()_. Если нечего возвращать, то возвращается значение null

  5. **componentDidUpdate(_prevProps, prevState, snapshot_)** вызывается сразу после обновления компонента (если _shouldComponentUpdate_ возвращает true)

  - _prevProps, prevState_ - старые значения объектов props и state
  - _snapshot_ \- значение, которое вернул метод _getSnapshotBeforeUpdate_
  - метод обычно используется для обновления DOM в ответ на изменение пропсов или состояния

- **_размонтирование_**
  - **componentWillUnmount()** вызывается перед размонтированием, позволяет отменить любые исходящие сетевые запросы или удалить все прослушиватели событий, связанные с компонентом

## Компонент высшего порядка (Higher Order Component, HOC)

- это функция-обертка, которая принимает компонент и возвращает новый компонент с дополнительной функциональностью

- _HOC_ не должен менять поведение и оригинальное предназначение оборачиваемого компонента

[Подробнее...](https://ru.legacy.reactjs.org/docs/higher-order-components.html)

## События

React самостоятельно перехватывает все события, возникающие в DOM, и транслирует их во внутреннюю систему.

В любой обработчик события при вызове передаётся объект типа **SyntheticEvent**, кроссбраузерный «враппер» (обёртка) над нативным объектом события. С точки зрения интерфейса он не отличается от нативного, кроме того, что работает одинаково во всех браузерах.

_SyntheticEvent_ хранит в себе оригинальный объект события и предоставляет интерфейс для доступа к его свойствам и методам. Этот интерфейс одинаков для всех браузеров, что крайне удобно с точки зрения разработки.

Полезные методы события:

**preventDefault()** - отменить действие по умолчанию

**stopPropagation()** - предотвратить всплытие события
