# Основные команды Git 


## инициализация git-репозитория

`git init` В текущей папке создается скрытая подпапка .git, где будет храниться вся служебная информация.
Если эту подпапку удалить, текущая папка перестанет быть "загитченой"

## клонирование чужого репозитория

`git clone АККАУНТ/URL`


## текущее состояние репозитория

`git status`

## подготовка к сохранению

`git add ` маркирует файлы как отслеживаемые и фиксирует содержимое указанных файлов для последующего сохранения их в репозитории

`git add --all ` подготовить к сохранению все файлы проекта

`git add todo.txt ` подготовить к сохранению файл todo.txt

`git add . ` подготовить к сохранению всю текущую папку


## сохранение файлов в репозитории

`git commit` сохраняются все ранее подготовленные файлы
в репозиторий переносится то содержимое файлов, которое было актуально на момент выполнения команды *git add*

`git commit -m "Здесь должно быть название коммита" `


### изменение последнего коммита

`git commit --amend --no-edit ` Дополнит коммит новыми файлами, сообщение не изменится

`git commit --amend -m "Обновлённое сообщение коммита" ` Изменит только сообщение


## история коммитов

`git log ` по умолчанию коммиты выводятся в обратном хронологическом порядке 

`git log --oneline `вывод в сжатом формате - часть хеша и название коммита 


## привязка удалённого репозитория к локальному

`git remote add` команде необходимо передать два параметра: имя удалённого репозитория и его URL.

`git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git `

*предварительно на компьютере должны быть сгенерированы ssh-ключи*
*и публичный ключ указан в настройках удаленного репозитория*
[Как сгенерировать ssh-ключи](https://practicum.yandex.ru/trainer/git-basics/lesson/19d174db-bd33-4307-a8e7-61b749a1639c/ )


## проверка, что репозитории связаны

```bash
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```

## отправка изменений в удалённый репозиторий

`git push`
В первый раз эту команду нужно вызвать с флагом *-u* и параметрами *origin* (имя удалённого репозитория) 
и *main* или *master* (название текущей ветки).
Флаг *-u* свяжет локальную ветку с одноимённой удалённой.

`git push -u origin main ` Если команда приведёт к ошибке, заменить main на master.

В дальнейшем при работе с удалённым репозиторием флаг *-u* можно опустить и писать просто *git push*.


## сравнение версий 

`git diff `   сравнит последнюю закоммиченную версию файла с той, что находится в состоянии *modified*.

`git diff --staged ` покажет изменения в staged-файлах относительно последних закоммиченных версий

`git diff <коммит1> <коммит2> ` сравнит два коммита, показав список инструкций: как превратить состояние <коммит1> в состояние <коммит2>


# Хеширование коммитов

Информация о коммите — это набор данных:
- когда был сделан коммит, 
- содержимое файлов в репозитории на момент коммита
- ссылка на предыдущий, или родительский коммит

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 
(*Secure Hash Algorithm* — безопасный алгоритм хеширования)
и получает для каждого коммита свой уникальный **хеш** — результат хеширования.
Обычно это короткая (4040 символов в случае SHA-1) строка, 
которая состоит из цифр 0—90—9 и латинских букв A—FA—F (неважно, заглавных или строчных).

Она обладает следующими важными свойствами:
- если хеш получить дважды для одного и того же набора входных данных,
  то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ),
  то хеш тоже изменится (причём сильно).
 
**Хеш** — основной идентификатор коммита, 
он позволяет узнать автора, дату и содержимое закоммиченных файлов,
его можно передавать различным git-командам в качестве параметра.
 
Все хеши, а также таблицу соответствий **хеш** → *информация о коммите* Git хранит в папке .git

В числе прочих файлов в папке .git есть служебный файл **HEAD**. Он указывает на самый свежий коммит.
Если надо передать хеш последнего коммита в качестве параметра можно написать слово *HEAD* 


# Статусы файлов

- Статусом **untracked** помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. 
  Этот статус — противоположность **tracked**, в который попадают все файлы, отслеживаемые Git.
- Файл переходит в статус **staged** после выполнения *git add*.
- Статус **modified** означает, что файл был изменён.
    
``` bash
  mermaid
graph LR;
  A[untracked];
  B[staged/tracked];
  C[tracked];
  D[modified];
  A -- "git add" --> B;
  D -- "git add" --> B;
  B -- "git commit" --> C;
  B -- "изменения" --> D;
  C -- "изменения" --> D;
```	

# Отмена изменений

## git restore

`git restore <file> ` откат файла до последней сохранённой (в коммите или в staging) версии

`git restore --staged <file> ` статус файла вернется в состояние modified или untracked


## git reset

Только для локальной истории!

`git reset --soft <commit hash> `  мягкий откат истории до коммита с хешем <hash>. Происходит только сброс дерева коммитов, не затрагивая дерева проиндексированных файлов и дерева рабочих файлов.

`git reset --mixed <commit hash> ` смешанный откат. Это режим работы по умолчанию. Сброс дерева коммитов и дерева проиндексированных файлов. Рабочие файлы не меняются. 

`git reset --hard <commit hash> ` жесткий откат. Более поздние коммиты потеряются. Рабочие файлы возвращаются к состоянию указанного коммита!


# *.gitignore*

текстовый файл в корне проекта со списком шаблонов
файл, соответствующий хотя бы одному шаблону, будет игнорироваться гитом

`git status --ignored ` покажи список всех игнорируемых файлов




# Работа с ветками


## создание веток

`git branch feature/the-finest-branch` создай ветку от текущей с названием feature/the-finest-branch;

`git checkout -b feature/the-finest-branch` создай ветку feature/the-finest-branch и сразу переключись на неё.


## навигация по веткам

`git branch ` покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *);

`git checkout feature/br` переключись на ветку feature/br.


## сравнение веток

`git diff main HEAD ` покажи разницу между веткой main и указателем на HEAD;

`git diff HEAD~2 HEAD ` покажи разницу между тем коммитом, который был два коммита назад, и текущим.


## удаление веток

`git branch -d br-name ` удали ветку br-name, но только если она является частью main;

`git branch -D br-name ` удали ветку br-name, даже если она не объединена с main.


## слияние веток

`git merge main ` объедини ветку main с текущей активной веткой. 


## работа с удалённым репозиторием

`git push -u origin my-branch ` отправь новую ветку my-branch в удалённый репозиторий и свяжи локальную ветку с удалённой,  чтобы при дополнительных коммитах можно было писать просто git push без -u;

`git push my-branch ` отправь дополнительные изменения в ветку my-branch, которая уже существует в удалённом репозитории;

`git pull ` подтяни изменения текущей ветки из удалённого репозитория.
