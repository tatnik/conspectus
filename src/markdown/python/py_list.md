# Списки, кортежи, массивы

## Списки (`list`)

- Список — изменяемая последовательность элементов.
- Универсальный контейнер для хранения элементов **любого типа** (числа, строки, другие списки и т.д.).
- Динамические: размер может меняться на ходу.
- Поддерживают все основные операции (индексация, срезы, добавление/удаление элементов и т.д.).
- Наиболее часто используемый тип коллекции в Python.

### Создание списка

```jsx
numbers = [1, 2, 3, 4];
words = ['apple', 'banana', 'cherry'];
mixed = [1, 'text', True, 3.14];
empty = [];
```

### Индексация и срезы

```jsx
fruits = ["яблоко", "груша", "слива"]
print(fruits[0])     # 'яблоко'
print(fruits[-1])    # 'слива'
print(fruits[1:])    # ['груша', 'слива']
```

### Основные методы списков

| Метод           | Описание                                                  | Пример               | Результат            |
| --------------- | --------------------------------------------------------- | -------------------- | -------------------- |
| `.append(x)`    | Добавить элемент в конец                                  | `lst.append(5)`      | `[1, 2, 3, 5]`       |
| `.extend(seq)`  | Добавить несколько элементов из другой последовательности | `lst.extend([6, 7])` | `[1, 2, 3, 6, 7]`    |
| `.insert(i, x)` | Вставить x на позицию i                                   | `lst.insert(1, 9)`   | `[1, 9, 2, 3]`       |
| `.remove(x)`    | Удалить первый x                                          | `lst.remove(2)`      | `[1, 3]`             |
| `.pop([i])`     | Удалить и вернуть элемент по индексу                      | `lst.pop()`          | возвращает последний |
| `.index(x)`     | Получить индекс первого x                                 | `lst.index(3)`       | `2`                  |
| `.count(x)`     | Сколько раз встречается x                                 | `lst.count(3)`       | `1`                  |
| `.sort()`       | Сортировка списка                                         | `lst.sort()`         | `[1, 2, 3]`          |
| `.reverse()`    | Переворот списка                                          | `lst.reverse()`      | `[3, 2, 1]`          |
| `len(lst)`      | Количество элементов                                      | `len(lst)`           | `3`                  |

---

## Кортежи (`tuple`)

- Кортеж — неизменяемая последовательность элементов.
- Записывается в круглых скобках, например: `(1, 2, 3)`

```jsx
point = (3, 5)
colors = ("red", "green", "blue")
single = (42,)  # запятая обязательна для одноэлементного кортежа
```

- Все операции индексации и срезов для кортежей работают так же, как и для списков.
- Методов у кортежа мало: только `count`, `index`, а также функция `len()`.

---

## Вложенные структуры

- В Python можно делать списки внутри списков (или кортежей), создавать "матрицы" и сложные структуры.

```jsx
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[1][2])  # 6 (вторая строка, третий столбец)
```

---

## Генераторы списков (List Comprehensions)

- Позволяют компактно создавать новые списки на основе существующих коллекций.
- Синтаксис: `[выражение for элемент in коллекция if условие]`

```jsx
squares = [x ** 2 for x in range(5)]
print(squares)  # [0, 1, 4, 9, 16]
```

- С условиями:

```jsx
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # [0, 2, 4, 6, 8]
```

- Для вложенных структур:

```jsx
flat = [x for row in matrix for x in row]
print(flat)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

## Генераторные выражения (generator expressions)

- Позволяют создавать генераторы — "ленивые" объекты, которые вычисляют элементы по мере запроса (экономят память).
- Синтаксис похож на списковое включение, но в круглых скобках: `(выражение for элемент in коллекция if условие)`

### Примеры:

```jsx
nums = range(5)
gen = (x**2 for x in nums)
print(next(gen))  # 0
print(next(gen))  # 1
print(list(gen))  # [4, 9, 16]
```

- Генераторные выражения часто используют как аргументы функций:

```jsx
total = sum(x**2 for x in range(10))
print(total)  # 285
```

---

### Зачем нужны генераторы?

- Экономят память при работе с большими коллекциями — элементы вычисляются по мере необходимости.
- Подходят для обработки "потоков" данных (файлы, web и т.д.).

---

### Сравнение:

|            | List Comprehensions         | Генераторное выражение  |
| ---------- | --------------------------- | ----------------------- |
| Скобки     | Квадратные `[ ... ]`        | Круглые `( ... )`       |
| Возвращает | Список (`list`)             | Генератор (`generator`) |
| Память     | Все элементы сразу в памяти | Вычисляет по запросу    |

## Массивы (`array.array`)

- **array** — специальный тип из стандартного модуля `array`.
- Используется для хранения **однородных элементов одного типа** (например, только целые числа, только float).
- Более экономно используют память и быстрее работают с большим числом однотипных данных.
- Поддерживают почти те же операции, что и списки, но **не могут содержать элементы разных типов**.

```jsx
import array

# Создаём массив из целых чисел
arr = array.array('i', [1, 2, 3, 4, 5])
print(arr[2])  # 3
```

- Первый аргумент — тип элементов (например, `'i'` — int, `'f'` — float, `'d'` — double).
- Подробнее о типах см. [документация array](https://docs.python.org/3/library/array.html).

---

### Основные отличия от списков

| Списки (`list`)                      | Массивы (`array.array`)        |
| ------------------------------------ | ------------------------------ |
| Могут содержать элементы любых типов | Только элементы одного типа    |
| Универсальны и гибки                 | Быстрее и компактнее для чисел |
| Медленнее при больших объёмах данных | Экономнее по памяти            |
| Не требуют импортов                  | Требуют `import array`         |

---

### Когда использовать массивы?

- Когда нужно эффективно хранить и быстро обрабатывать **большие объёмы однотипных данных** (например, много целых или float).
- Если нужны операции на уровне памяти (например, для передачи данных в C-расширения).
- **Для научных и инженерных расчётов** обычно используют не `array`, а библиотеку [NumPy](https://numpy.org/) — она даёт массивы с возможностями выше.

---

## Функция zip()

**zip()** — встроенная функция Python для “сшивания” нескольких итерируемых объектов (списков, кортежей, строк и т.д.) в кортежи, объединяя элементы с одинаковыми индексами в каждой последовательности.

---

### Как работает zip()

- Принимает на вход две или больше последовательностей.
- Возвращает итератор, на каждом шаге которого выдаётся кортеж из элементов с одинаковым индексом.
- Если длины последовательностей не совпадают, результат будет по самой короткой.

**Пример с двумя списками:**

```python
a = [1, 2, 3]
b = ["a", "b", "c"]
for pair in zip(a, b):
    print(pair)
# (1, 'a')
# (2, 'b')
# (3, 'c')
```

**Пример с разной длиной:**

```python
a = [1, 2, 3]
b = [10, 20]
print(list(zip(a, b)))
# [(1, 10), (2, 20)]
```

**Обратная операция (распаковка с помощью \*):**

```python
pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
a, b = zip(*pairs)
print(list(a))  # [1, 2, 3]
print(list(b))  # ['a', 'b', 'c']
```

---

### Типичные применения

- Одновременный обход нескольких списков.
- Построение пар “ключ-значение” из двух списков.
- Транспонирование матриц (переворот строк и столбцов):

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6]
]
transposed = list(zip(*matrix))
print(transposed)
# [(1, 4), (2, 5), (3, 6)]
```

---

### Типичные ошибки

- Попытка обработать последовательности разной длины — лишние элементы игнорируются.
- zip() возвращает итератор — для повторного использования преобразуйте в list().
- Если распаковываете пустую коллекцию: `zip(*[])` выдаст ошибку ValueError.

---

### Ссылки

- [Документация zip()](https://docs.python.org/3/library/functions.html#zip)
- [Real Python: Python’s zip() Function](https://realpython.com/python-zip-function/)

---
