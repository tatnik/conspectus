# Основы функционального программирования в Python

**Функциональное программирование** — это стиль программирования, в котором вычисления строятся как композиция функций, не изменяющих состояния (без побочных эффектов).

---

## Основные принципы

- **Функции — объекты первого класса:** функции можно передавать как аргументы, возвращать из других функций, присваивать переменным.
- **Чистые функции:** результат зависит только от входных данных, нет изменений внешних переменных.
- **Отсутствие побочных эффектов:** функция ничего не изменяет вне себя (не пишет в файлы, не изменяет глобальные переменные и т.п.).
- **Иммутабельность:** переменные не изменяются после создания (например, строки, кортежи).
- **Функции высшего порядка:** принимают функции как аргументы или возвращают функции (см. прошлый конспект).
- **Рекурсия:** решение задачи через вызов функции самой себя (вместо циклов).
- **Ленивые вычисления:** значения вычисляются по мере необходимости (например, генераторы).

---

## Чистая функция

```jsx
def add(a, b):
    return a + b
# Всегда при одних и тех же a и b будет одинаковый результат
```

## map(func, iterable)

- Применяет функцию ко всем элементам последовательности.

```jsx
numbers = [1, 2, 3]
squares = list(map(lambda x: x ** 2, numbers))
print(squares)  # [1, 4, 9]
```

---

## filter(func, iterable)

- Отбирает элементы, для которых функция возвращает True.

```jsx
words = ["cat", "dog", "elephant"]
short = list(filter(lambda w: len(w) <= 3, words))
print(short)  # ['cat', 'dog']
```

---

## reduce(func, iterable)

- Итеративно сводит всю последовательность к одному значению (например, произведение).
- Входит в модуль `functools`.

```jsx
from functools import reduce

numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 24
```

---

## sorted(iterable, key=func)

- Сортирует элементы по значению функции.

```jsx
names = ['Ann', 'boris', 'Vika']
print(sorted(names, key=lambda x: x.lower()))
# ['Ann', 'boris', 'Vika']
```

## Генераторы и ленивые вычисления

```jsx
gen = (x**2 for x in range(10))  # генератор-выражение
print(next(gen))  # 0
print(next(gen))  # 1
```

---

## Использование функций как аргументов

```jsx
def apply(func, data):
    return [func(x) for x in data]

print(apply(abs, [-3, -2, 0, 4]))  # [3, 2, 0, 4]
```

## Возврат функций из функции

```jsx
def make_power(n):
    def power(x):
        return x ** n
    return power

cube = make_power(3)
print(cube(2))  # 8
```

---

## Композиция функций (через вложенность)

```jsx
def double(x): return x * 2
def square(x): return x ** 2

result = double(square(3))  # 18
```

---

## Рекурсия

```jsx
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

---

## Ограничения Python

- Python поддерживает функциональный стиль, но не запрещает использовать переменные, которые могут изменяться.
- Для "чистого" функционального программирования существуют другие языки (Haskell, Erlang и др.).
- Однако функции, генераторы, lambda, map/filter/reduce, immutability — активно применяются и в Python.

---
