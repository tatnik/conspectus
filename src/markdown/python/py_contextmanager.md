# Контекстные менеджеры в Python

**Контекстные менеджеры** — это объекты, которые управляют выделением и освобождением ресурсов, а также автоматизацией некоторых процедур (например, открытие/закрытие файлов, блокировки, сетевые соединения, временные изменения настроек и т.д.). Контекстные менеджеры реализуют протокол с помощью методов `__enter__` и `__exit__` и используются через ключевое слово `with`.

---

## Термины

- **Контекст** — область, внутри которой действуют определённые правила или гарантии (например, файл открыт, соединение установлено и т.д.).
- **Протокол контекстного менеджера** — соглашение, что объект должен реализовать методы `__enter__` и `__exit__`.
- **Вход в контекст (`__enter__`)** — выполняется при входе в блок `with`, возвращает управляемый ресурс.
- **Выход из контекста (`__exit__`)** — выполняется при выходе из блока (даже если возникло исключение), используется для освобождения ресурса и/или обработки ошибок.

---

## Простой пример: класс с методами `__enter__` и `__exit__`

```python
class FileOpener:
    def __enter__(self):
        self.file = open('example.txt', 'w')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        self.file.close()

with FileOpener() as f:
    f.write("Привет, мир!")
# Файл будет закрыт автоматически, даже если возникла ошибка
```

---

## Использование стандартных контекстных менеджеров

Открытие файла — самый известный пример:

```python
with open('example.txt', 'r') as f:
    text = f.read()
# Файл закроется автоматически при выходе из блока
```

---

## Создание контекстного менеджера через `contextlib`

Модуль `contextlib` позволяет создавать контекстные менеджеры при помощи декоратора `@contextmanager`:

```python
from contextlib import contextmanager

@contextmanager
def custom_context():
    print("Начало работы")
    resource = {"key": 42}
    try:
        yield resource
    finally:
        print("Конец работы")

with custom_context() as res:
    print("Внутри блока:", res)
```

### Интересные стандартные менеджеры из `contextlib`

- `contextlib.suppress` — игнорирует указанные исключения:

```python
from contextlib import suppress

with suppress(FileNotFoundError):
    open('нет_такого_файла.txt')
# Не будет ошибки, даже если файл не существует
```

- `contextlib.redirect_stdout` — перенаправляет вывод:

```python
from contextlib import redirect_stdout

with open('out.txt', 'w') as f, redirect_stdout(f):
    print("Это попадёт в файл out.txt")
```

- `contextlib.ExitStack` — позволяет динамически комбинировать несколько менеджеров:

```python
from contextlib import ExitStack

with ExitStack() as stack:
    files = [stack.enter_context(open(f'file{i}.txt', 'w')) for i in range(3)]
    for idx, f in enumerate(files):
        f.write(f"Файл номер {idx}")
```

---

## Интересные фишки и неочевидные детали

- Если в методе `__exit__` вернуть `True`, исключение внутри блока будет подавлено (не проброшено дальше).
- Можно использовать контекстные менеджеры не только для работы с файлами, но и для управления транзакциями в базах данных, блокировками потоков, временными изменениями окружения, и даже для профилирования кода (см. `contextlib`).
- Контекстные менеджеры поддерживают вложенность (можно вкладывать друг в друга сколько угодно).
- Менеджеры из `contextlib` можно применять как декораторы для функций.

---

## Типичные ошибки и подводные камни

- Забыли реализовать оба метода — `__enter__` и `__exit__`: если одного не хватает, менеджер не будет работать корректно.
- Возвратили что-то отличное от `True` в `__exit__` — исключение не подавляется (обычно это правильно, но иногда требуется именно подавить).
- Освобождаете ресурс только при отсутствии ошибок: обязательно используйте блок `finally` или корректную реализацию `__exit__`, чтобы освобождение происходило всегда.
- Использование менеджеров для ресурсов, которые нужно часто и быстро открывать/закрывать, может быть неэффективно (например, постоянно открывать/закрывать один и тот же файл).

---

## Ссылки на документацию и полезные ресурсы

- [Официальная документация: Контекстные менеджеры (Python docs)](https://docs.python.org/3/reference/datamodel.html#context-managers)
- [contextlib — Utilities for with-statement contexts](https://docs.python.org/3/library/contextlib.html)
