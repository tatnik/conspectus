# Функции и области видимости

## Объявление и вызов функций

- Функция объявляется с помощью ключевого слова `def`:

```jsx
def greet(name):
    print(f"Привет, {name}!")

greet("Кирилл")  # Вызов функции
```

- Функция может возвращать значение с помощью `return`:

```jsx
def add(a, b):
    return a + b

result = add(2, 3)   # result = 5
```

Функция без `return` возвращает None

---

## Аргументы по умолчанию

- Можно задать значения по умолчанию для аргументов:

```jsx
def greet(name, msg="Добро пожаловать!"):
    print(f"{msg}, {name}!")

greet("Алиса")                    # Добро пожаловать!, Алиса!
greet("Боб", "Приветствую")       # Приветствую, Боб!
```

---

## \*args и \*\*kwargs

## Что такое \*args и \*\*kwargs?

- `*args` — позволяет функции принимать любое количество **позиционных аргументов** (упаковываются в кортеж).
- `**kwargs` — позволяет принимать любое количество **именованных (ключ=значение) аргументов** (упаковываются в словарь).

---

## Как использовать \*args

```jsx
def show_args(*args):
    print(args)

show_args(1, 2, 3)
# (1, 2, 3)
```

- Можно перебирать аргументы:

```jsx
def summator(*args):
    total = 0
    for num in args:
        total += num
    return total

print(summator(1, 2, 3, 4))   # 10
```

---

### Как использовать \*\*kwargs

```jsx
def show_kwargs(**kwargs):
    print(kwargs)

show_kwargs(a=1, b=2)
# {'a': 1, 'b': 2}
```

- Можно перебирать ключи и значения:

```jsx
def print_user(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_user(name="Анна", age=30)
# name: Анна
# age: 30
```

---

### Совмещённое использование \*args и \*\*kwargs

```jsx
def demo(a, *args, **kwargs):
    print(f"a = {a}")
    print(f"args = {args}")
    print(f"kwargs = {kwargs}")

demo(1, 2, 3, x=10, y=20)
# a = 1
# args = (2, 3)
# kwargs = {'x': 10, 'y': 20}
```

---

### Передача \*args и \*\*kwargs дальше

- Можно "распаковать" и передать аргументы другой функции:

```jsx
def f1(*args, **kwargs):
    print(args, kwargs)

def f2(*args, **kwargs):
    f1(*args, **kwargs)

f2(1, 2, x=10)
# (1, 2) {'x': 10}
```

---

### Использование с обычными аргументами

- Сначала идут обычные аргументы, потом `*args`, затем `**kwargs`:

```jsx
def func(a, b, *args, c=42, **kwargs):
    print(a, b, args, c, kwargs)

func(1, 2, 3, 4, c=5, x=10)
# 1 2 (3, 4) 5 {'x': 10}
```

---

### Распаковка \*args и \*\*kwargs при вызове функции

- `*` — распаковывает последовательность (список, кортеж) в позиционные аргументы.
- `**` — распаковывает словарь в именованные аргументы.

```jsx
def baz(a, b, c=0, d=0):
    print(a, b, c, d)

args = (1, 2)
kwargs = {'d': 4, 'c': 3}
baz(*args, **kwargs)   # Эквивалентно baz(1, 2, c=3, d=4)
# Выведет: 1 2 3 4
```

## можно использовать любые имена переменных для распаковки аргументов — главное, чтобы перед распаковкой стояли звёздочки \* и \*\*

**Итого:**

- `*args` — для переменного количества позиционных аргументов (tuple).
- `**kwargs` — для переменного количества именованных аргументов (dict).
- Можно перебирать, комбинировать, передавать дальше, распаковывать при вызове.

---

## Области видимости

**Область видимости** — это контекст, в котором "видна" (доступна) переменная или функция.

В Python существует правило LEGB — четыре уровня областей видимости:

1. **Local (локальная)** — внутри текущей функции или блока.
2. **Enclosing (замыкающая, nonlocal)** — во вложенной функции: область внешней (но не глобальной) функции.
3. **Global (глобальная)** — на уровне модуля (файла), вне всех функций и классов.
4. **Built-in (встроенная)** — предопределённые имена Python (например, `len`, `list`).

---

### Как создаются области видимости?

- **Локальная область** создаётся при вызове функции.
- **Замыкающая (enclosing)** область создаётся при наличии вложенных функций.
- **Глобальная область** создаётся при запуске каждого модуля (файла).
- **Встроенная область** задаётся интерпретатором Python автоматически.

---

### Примеры

#### Локальная и глобальная

```jsx
x = 10  # глобальная переменная

def foo():
    x = 5  # локальная переменная
    print(x)

foo()      # 5
print(x)   # 10
```

#### Замыкающая (enclosing) область

```jsx
def outer():
    y = 20  # enclosing переменная
    def inner():
        print(y)  # ищет y во внешней функции
    inner()

outer()    # 20
```

#### Глобальная область: global

Чтобы изменить глобальную переменную внутри функции, используют ключевое слово `global`:

```jsx
counter = 0

def increment():
    global counter
    counter += 1

increment()
print(counter)   # 1
```

#### Замыкающая область: nonlocal

Чтобы изменить переменную во внешней (enclosing) функции — используем `nonlocal`:

```jsx
def outer():
    x = 0
    def inner():
        nonlocal x
        x += 1
        print(x)
    inner()
    inner()

outer()
# 1
# 2
```

---

### Built-in область

- Все стандартные функции и имена (например, `print`, `sum`, `int`, `Exception`) находятся во встроенной области.

---

### Как Python ищет переменную?

- Сначала в **локальной** области (Local)
- Затем во **внешней** функции (Enclosing)
- Затем в **глобальной** (Global)
- Потом во **встроенной** (Built-in)
- Если не нашёл — будет ошибка `NameError`

---

- Для вложенных функций удобно использовать `nonlocal` для изменения переменных enclosing-области.
- Имена переменных внутри функций "закрывают" (скрывают) одноимённые переменные из внешних областей.

---
