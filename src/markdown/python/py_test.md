# Тестирование в Python

**Тестирование** — неотъемлемая часть современного процесса разработки, позволяющая автоматически проверять корректность работы кода, быстро обнаруживать ошибки и регрессии, гарантировать качество изменений.

В Python наиболее популярны два инструмента: встроенный модуль `unittest` и внешний фреймворк `pytest`.

---

## unittest

- Встроенный модуль для написания юнит-тестов.
- Основан на концепции классов-наследников `unittest.TestCase`, методы которых считаются тестами, если начинаются с `test_`.
- Для организации тестовых наборов — методы setUp, tearDown (автоматически вызываются до/после каждого теста).

**Пример простого теста:**

```python
import unittest

def add(a, b):
    return a + b

class TestAdd(unittest.TestCase):
    def test_simple(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)

    def test_types(self):
        with self.assertRaises(TypeError):
            add("a", 1)

if __name__ == "__main__":
    unittest.main()
# .
# ----------------------------------------------------------------------
# Ran 2 tests in 0.000s
# OK
```

---

## pytest

- Более лаконичный и гибкий фреймворк, не требует написания классов, тесты — обычные функции.
- Автоматически находит тестовые файлы и функции по паттерну `test_*.py`, `test_*`.
- Поддерживает расширения: мокирование, фикстуры, параметризацию, проверки исключений и др.

**Пример простого теста:**

```python
def add(a, b):
    return a + b

def test_simple():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0

import pytest
def test_types():
    with pytest.raises(TypeError):
        add("a", 1)
# pytest test_module.py
# ========================= test session starts =========================
# ...
# ========================== 2 passed in 0.01s ==========================
```

---

## Мокирование (замена объектов на поддельные)

- **unittest.mock** — стандартная библиотека для подмены функций/объектов при тестировании (“моки”, “шпионы”).
- Используется для изоляции теста от внешних зависимостей: файловой системы, БД, сетевых вызовов и пр.

**Пример мокирования:**

```python
from unittest.mock import Mock

def fetch_data(api):
    return api.get()

def test_fetch_data():
    mock_api = Mock()
    mock_api.get.return_value = {"key": "value"}
    assert fetch_data(mock_api) == {"key": "value"}
```

- В pytest можно использовать мок-фикстуру: `monkeypatch`, либо встроенный `unittest.mock`.

---

## Фикстуры

- **Фикстура** — объект или функция, автоматически вызываемая для подготовки окружения или данных для теста.
- В `pytest` объявляется через декоратор `@pytest.fixture`.
- Фикстуры могут использоваться как для отдельного теста, так и для группы тестов (scope='module', 'session', ...).

**Пример фикстуры:**

```python
import pytest

@pytest.fixture
def sample_dict():
    return {"a": 1, "b": 2}

def test_sample(sample_dict):
    assert "a" in sample_dict
    assert sample_dict["b"] == 2
```

---

## Параметризация тестов

- Позволяет запускать один и тот же тест с разными наборами данных.
- В pytest используется декоратор `@pytest.mark.parametrize`.

**Пример:**

```python
import pytest

@pytest.mark.parametrize("a,b,result", [
    (2, 3, 5),
    (-1, 1, 0),
    (0, 0, 0)
])
def test_add(a, b, result):
def test_add(a, b, result):
    assert add(a, b) == result
# Тест будет выполнен три раза с разными значениями a, b, result
```

---

## Интересные детали и фишки

- pytest поддерживает удобный вывод ошибки с подробным сравнение ожидаемого и фактического результата.
- Для интеграционных тестов можно запускать фикстуры на уровне модуля/сессии (например, подготовить тестовую базу данных).
- Можно использовать автопоиск тестов по папкам и маскам, запускать только изменённые или провалившиеся тесты.
- Для мокирования дат, времени, случайности существуют специальные плагины (`freezegun`, `pytest-randomly` и др.).

---

## Типичные ошибки и подводные камни

- Тест зависит от внешних ресурсов (сети, файлов) и может быть нестабилен — используйте моки.
- Не обрабатываются исключения, тест падает некорректно — используйте проверки ошибок и фикстуры для “чистки” окружения.
- Неиспользование фикстур приводит к дублированию кода подготовки данных.
- Некорректная параметризация (рассогласование числа параметров и аргументов).

---

## Ссылки на документацию и полезные ресурсы

- [Документация unittest](https://docs.python.org/3/library/unittest.html)
- [Документация pytest (рус)](https://pytest-ru.readthedocs.io/ru/latest/)
- [unittest.mock](https://docs.python.org/3/library/unittest.mock.html)
- [pytest: Fixtures](https://docs.pytest.org/en/stable/how-to/fixtures.html)
- [pytest: Параметризация тестов](https://docs.pytest.org/en/stable/example/parametrize.html)
