### Объекты и классы в JS. Прототипы. Типы методов.

## Класс

- универсальный, комплексный тип данных, состоящий из тематически единого набора свойств (переменных) и методов (функций).

- шаблон для объекта, которые описывает его свойства и методы

- является ссылочным типом

## Объект

- созданный экземпляр класса

- на объект можно сослаться с помощью идентификатора

---

## Основные принципы ООП

### Абстракция

- выделение в моделируемом предмете сущностей, важных для решения конкретной задачи (выделение значимой информации, исключение незначимой).
  [Подробнее про абстрактные классы, методы и полиморфизм](https://habr.com/ru/articles/37576/)

### Инкапсуляция

- сокрытие внутренней структуры данных и реализации методов от остальной программы. Взаимодействие с объектом осуществляется только через интерфейс.

### Наследование

- позволяет описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

- класс, от которого производится наследование называется **базовым, родительским, суперклассом**

- новый класс - **потомком, наследником, дочерним или производным** классом

### Полиморфизм

- дает возможность использовать одни и те же методы для объектов разных классов
  [Подробнее...](https://skillbox.ru/media/code/prostymi-slovami-o-polimorfizme-5-chast-gayda-po-oop/)

---

## Прототипы

JavaScript — язык с прототипным наследованием: каждый объект может быть связан с другим объектом (“прототипом”), и получать его свойства и методы. Это фундамент JS, позволяющий реализовать наследование и расширять поведение объектов.

- Каждый объект имеет скрытое свойство [[Prototype]] (или **proto**), которое ссылается на другой объект или null.
- При обращении к свойству/методу объекта, если такого нет “в самом объекте”, поиск идёт по цепочке прототипов до самого верха (Object.prototype → null).
- Прототип — это основной механизм наследования и переиспользования кода в JS.

**Пример:**

```js
const animal = { eats: true };
const rabbit = { jumps: true };

rabbit.__proto__ = animal; // теперь rabbit наследует от animal

console.log(rabbit.eats); // true (из animal)
console.log(rabbit.jumps); // true (своё свойство)
```

- Современный стиль — использовать Object.create/prototype, а не прямое присваивание **proto**.

---

## Конструкторы и свойство prototype

- Функция-конструктор (обычно с большой буквы) используется для создания объектов через new.
- У каждой функции есть свойство prototype — именно оно становится прототипом всех создаваемых объектов, созданных этим конструктором.

```js
function User(name) {
  this.name = name;
}
User.prototype.sayHi = function () {
  console.log('Привет, ' + this.name);
};

const u = new User('Вася');
u.sayHi(); // Привет, Вася
console.log(u.__proto__ === User.prototype); // true
```

- Можно добавлять методы и свойства в prototype, и они будут доступны всем экземплярам.
- Встроенные объекты (Array, Function, Date и др.) тоже имеют свои прототипы.

---

## Классы (ES6+) и прототипы

- Синтаксический сахар над прототипами, фактически работают на прототипном наследовании.
- Всё, что определяется внутри класса, оказывается в prototype.

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log('Hi, ' + this.name);
  }
}
const p = new Person('Bob');
p.sayHi(); // Hi, Bob
console.log(Object.getPrototypeOf(p) === Person.prototype); // true
```

---

## Типы методов в JavaScript

### 1. Обычные методы объекта

- Определяются как свойства-функции в объекте, могут обращаться к this (текущий объект).

```js
const obj = {
  foo: function () {
    /* ... */
  },
  bar() {
    /* ... */
  }, // короткий синтаксис ES6
};
```

### 2. Методы прототипа

- Функции, добавленные в prototype конструктора или класса, доступны всем экземплярам.
- Экономят память: один объект-функция для всех экземпляров.

```js
function Animal() {}
Animal.prototype.speak = function () {
  console.log('Животное говорит');
};

const a = new Animal();
a.speak(); // "Животное говорит"
```

### 3. Статические методы

- Свойства-функции у конструктора/класса, а не у его prototype.
- Не наследуются экземплярами, доступны только самому конструктору/классу.

```js
class MyClass {
  static info() {
    return 'Статический метод';
  }
}
console.log(MyClass.info()); // "Статический метод"
```

### 4. Геттеры и сеттеры

- Позволяют задавать поведение при чтении/записи свойства.

```js
const obj = {
  get prop() {
    return 'getter';
  },
  set prop(value) {
    console.log('setter', value);
  },
};

console.log(obj.prop); // getter
obj.prop = 123; // setter 123
```

## Краткая таблица по типам методов

| Тип метода    | Где объявляется                  | Как вызывать      | Кто видит                |
| ------------- | -------------------------------- | ----------------- | ------------------------ |
| Статический   | В классе/конструкторе с `static` | Класс/конструктор | Только класс/конструктор |
| Прототипный   | В прототипе/классе               | Экземпляр         | Все экземпляры           |
| Собственный   | Внутри конструктора              | Экземпляр         | Только конкретный объект |
| Геттер/сеттер | В прототипе/классе/объекте       | Как свойство      | Все экземпляры           |

---

## Интересные детали и фишки

- Прототипы можно менять динамически: `Object.setPrototypeOf(obj, proto)`.
- Методы массива, строки, объекта берутся из соответствующих прототипов `(Array.prototype, String.prototype…)`.
- Для проверки наличия собственного свойства используют `hasOwnProperty`.
- Вся цепочка прототипов доступна через `Object.getPrototypeOf(obj)` и дальше.
- Можно расширять стандартные прототипы (например, добавлять свои методы к `Array.prototype`), но делать это не рекомендуется.

---

## Типичные ошибки и подводные камни

- `this` в методе зависит от того, как вызвана функция (теряется при передаче метода как `callback`).
- Переопределение `prototype` полностью “отрывает” старую цепочку, потеря встроенных методов.
- Использование `__proto__` не рекомендуется — лучше `Object.create, Object.setPrototypeOf`.
- Статические методы не видны у экземпляров — вызывать нужно у класса.

---

## Ссылки на документацию и полезные ресурсы

- [MDN: Прототипное наследование](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [MDN: Классы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)
- [Подробно про this, методы, статические методы (learn.javascript.ru)](https://learn.javascript.ru/prototype-methods)
