# Методы для работы с массивами

```js
[1, 2, 3].length; // 3

[1, 2, 3].[2]; // 3

[1, 2, 3].at(2); // 3
[1, 2, 3].at(-1); // 3
```

## создание нового массива

```js
new Array(3); // [undefined, undefined, undefined]

Array.of(1, 2, 3); // [1,2,3]
Array.of(7); // [7]

Array.from('123'); // ['1','2','3']
Array.from([1, 2, 3], (x) => x + x); //  [2, 4, 6]
Array.from({ length: 5 }, (v, k) => k); // [0, 1, 2, 3, 4]
```

## добавление/удаление элементов

```js
// возвращают новое значение length
[1, 2, 3].push(4); // [1,2,3,4]
[1, 2, 3].unshift(0); // [0,1,2,3]

// возвращают удаленный элемент
[1, 2, 3].pop(); // [1,2]
[1, 2, 3].shift(); // [2,3]
```

## поиск элемента

```js
arr.indexOf(searchElement[, fromIndex = 0]);

[1, 2, 3].indexOf(3); //2
[1, 2, 3].indexOf(4); // -1
[1, 2, NaN].indexOf(NaN); // -1,  использует строгое равенство

[1, 2, 3, 2].lastIndexOf(2); // 3


arr.includes(searchElement[, fromIndex = 0]);

[1, 2, 3].includes(3); // true
[1, 2, 3].includes(3, 3); // false
[1, 2, 3].includes(3, -1); // true , использует отрицательный индекс
[1, 2, NaN].includes(NaN); // true , не использует строгое равенство


arr.find(callback[, thisArg]);

[1, 2, 3, 4].find((num) => num > 2); // 3
[1, 2, 3, 4].find((num) => num > 5); // undefined


arr.findLast(callback[, thisArg]);

[5, 12, 50, 130, 44].find((num) => num > 45); // 130


arr.findIndex(callback[, thisArg]);

[1, 2, 3, 4].findIndex((num) => num > 2); // 2
[1, 2, 3, 4].findIndex((num) => num > 5); // -1
```

## конкатенация

```js
[1, 2, 3].concat([4, 5]); // [1,2,3,4,5]
```

## преобразования массива (меняют исходный массив)

### заполнение массива

```js
arr.fill(value[, start = 0[, end = this.length]]);

[1, 2, 3].fill(10); // [10,10,10]
```

### копирование элементов внутри массива

```js
arr.copyWithin(target, start[, end = this.length]);

[1, 2, 3, 4, 5, 6].copyWithin(0, 3, 5); // [4, 5, 3, 4, 5, 6]

```

### вырезка и вставка

```js
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
```

возвращает вырезанное, в исходный массив добавляет элементы вместо вырезанных

```js
[1, 4].splice(1, 0, 2, 3); // [1,2,3,4], вернет []
[1, 2, 3, 4, 5].splice(2, 3, 1); // [1,2,1], вернет [3,4,5]
```

### реверс

```js
array.reverse();

[1, 2, 3].reverse(); // [3,2,1]
```

### сортировка

если не указана функция сравнения, массив сортируется в соответствии со значениями кодовых точек каждого символа Unicode, полученных путём преобразования каждого элемента в строку

```js
arr.sort([compareFunction]);

[2, 1, 3].sort(); // [1,2,3]

['слово', 'Слово', '1 Слово', '2 Слова'].sort();
// ['1 Слово', '2 Слова', 'Слово', 'слово']

[2, 1, 3].sort((a, b) => a - b); // [1,2,3]
[2, 1, 3].sort((a, b) => b - a); // [3,2,1]
```

Функция в методе sort будет выполнена для каждой пары элементов внутри массива.

если compareFunction(a, b) <= 0, порядок не изменится: a, b;

если compareFunction(a, b) > 0, порядок изменится: b, a

## преобразование в строку

```js
[1, 2, 3].join('-'); // '1-2-3'

[1, 2, 3].toString(); // '1,2,3'
```

## вырезка

```js
[1, 2, 3, 4].slice(1, 3); // [2,3]
```

элементы копируются в новый массив: числа и строки - по значению, объекты - по ссылке

исходный массив не меняется

## проверка элементов массива на условие

```js
[1, 2, 3].every((num) => num > 1); //false
[1, 2, 3].some((num) => num === 3); //true
```

## проверка что это массив?

```js
Array.isArray('[1,2,3]'); // false;
```

## фильтрация массива

callback - функция будет вызвана для каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.

```js
arr.filter(callback(element[, index[, array]])[, thisArg])

[12, 5, 8, 130, 44].filter((value) => (value >= 10)); // [12, 130, 44]
```

## ftat (уплощение вложенных массивов)

```js
arr.flat([(depth = 1)]);

[1, 2, [3]].flat(); // [1,2,3]

[1, 2, [3, 4, [5, 6]]].flat(); // [1,2,3,4,[5,6]]
[1, 2, [3, 4, [5, 6]]].flat(2); // [1,2,3,4,5,6]
[1, 2, [3, 4, [5, 6, [7, 8]]]].flat(Infinity); // [1,2,3,4,5,6,7,8]

[1, 2, , 4, 5].flat(); // [1,2,4,5]
```

## map

```js
[1, 2, 3].map((num) => Math.pow(num, 2)); // [1,4,9]
```

## map + flat

```js
arr.flatMap(function callback(currentValue[, index[, array]]) {
// возвращает элемент для нового массива
}[, thisArg]);

[1, 2, 3, 4].flatMap((x)=> [x * 2]); // [2,4,6,8]

["Метод flatMap идентичен методу map", "", "с последующим вызовом flat"].flatMap((x) => x.split(" "));
// ['Метод', 'flatMap', 'идентичен', 'методу', 'map', '', 'с', 'последующим', 'вызовом', 'flat']
```

## reduce

```js
array.reduce(callback(accumulator, currentValue [, index] [, array]) [, initialValue]);

function sum(total, value) {
  return total + value;
}
[1, 2, 3, 4, 5, 6].reduce(sum ,0); //21

[1, 2, '3', 4, 5, 6].reduce(sum ,0); // '33456'

[[0, 1], [2, 3], [4, 5]].reduce((a, b) => a.concat(b)); // [0, 1, 2, 3, 4, 5]
```

## копирование массива

```js
const arr = [1, 2, 3];

const newArr = [...arr]; // [1,2,3]

const newArr = arr.slice(); // [1,2,3]

const newArr = Array.from(arr); // [1,2,3]
```
