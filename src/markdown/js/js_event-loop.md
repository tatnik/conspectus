# Event Loop

\- это цикл, который контролирует порядок передачи в стек вызовов задач, микрозадач и задач рендера.

## Call Stack

или стек вызовов — это механизм, который позволяет интерпретаторам JavaScript выполнять задачи в определнной последовательности. Когда в коде вызывается функция, интерпретатор кладет ее в стек. Любая вложенная функция также кладется «наверх» стека. Как только вложенность заканчивается, функции выполняются по принципу LIFO (последним пришел - первым ушел), то есть последняя добавленная в стек функция будет выполнена первой. Если, конечно, на момент добавления в стеке ничего больше не выполняется.

## Tasks

или задачи — это фрагменты кода, порядок выполнения которых определяется очередью. Примерами задач могут служить коллбеки event listener или загрузка внешнего скрипта. Все задачи, как было указано раньше, добавляется в очередь задач, откуда они передаются в стек вызовов, в порядке FIFO (первым пришел - первым ушел), то есть, передача задач в call stack, а следовательно, их выполнение происходят в порядке добавления.

## Microtasks

или микрозадачи — это асинхронные фрагменты кода, например, .then-метод у промисов. Их порядок выполнения также определяется очередью, но в этом случае, очередью микрозадач.

## Отличие задач от микрозадач

состоит в том, как очереди задач и микрозадач взаимодействуют со стеком вызовов. Очередь задач передает в стек вызовов одну задачу, после чего очередь микрозадач передает в стек все имеющиеся микрозадачи.

## Схема работы цикла

![event-loop](/conspectus/jpg/event-loop.jpg)

Сначала цикл передает в стек одну задачу, задача выполняется и покидает стек;
После того как стек станет пустым, цикл передает в него поочередно все микрозадачи. Они выполняются и стек пустеет;
После опустошения стека, цикл передает в него поочередно все задачи рендера.
Взаимодействие этого цикла с очередями, как раз то, что позволяет выполнять действия в коде асинхронно и рендерить изменения страницы не дожидаясь завершения всего кода.

## Чтобы Event Loop не забивался

необходимо крупные задачи и микрозадачи разбивать на шаги, используя setTimeout внутри await new Promise.

[Источник](https://worksolutions.ru/blog/event-loop-i-optimizacziya-prilozhenij-pri-pomoshhi-asinhronnogo-koda/)

## Особенности реализации Event Loop

**Event loop находится вне зоны ответственности спецификации ECMA-262**.

Официальный источник информации для Event loop - это **спецификация HTML**, в случае с браузерными средами, либо **официальная документация библиотек или самих _HOST_-исполнителей**, в случае с не браузерными средами.

Самой распространенной, на сегодняшний день, не браузерной средой является **Node.js**. Для обеспечения работы Event Loop, Node.js использует библиотеку **libuv**.

Мобильные среды, такие, как **React Native, NativeScript и Apache Cordova** тоже являются не браузерными. Они полагаются на **API** соответствующей ОС, в которой исполняются. Например для **Andriod** это **Android.os.Looper**, а для **iOS** - **RunLoop**.

В спецификации ECMA-262 есть косвенные отсылки к процессам, связанным с Event loop, но **реализацию этих процессов спецификация оставляет на совести HOST-исполнителя**.

_Event loop_ не завязан исключительно на обслуживание JavaScript кода. На самом деле, JavaScript - всего лишь один из типов задач, которые могут попасть в Event loop. Помимо JavaScript, браузер может помещать сюда задачи, например, на токенизацию полученного HTML текста, на обработку операций ввода/вывода, на отрисовку элементов на экране, и еще много чего другого.

_Event loop_, согласно спецификации HTML, не обязан быть потокобезопасным, но может таковым являться. В случае исполнения нескольких агентов со своим Event loop в одном потоке, они должны самостоятельно организовать алгоритм взаимодействия друг с другом, так, чтобы в одну единицу времени разблокированным агентом был только один из них, остальные должны находиться в состоянии блокировки.

## Еще немного про очереди

_Event loop_ состоит из **task queue** и **microtask queue**.

В **task queue** попадают задачи, поставленные _HOST_-исполнителем,

**microtask queue** - это опциональная возможность для задачи из **task queue** воспользоваться _Web API_ исполнителя с целью выполнения каких-либо своих специфических асинхронных подзадач.

Примечательно, что, несмотря на звание, _task queue_ очередью, на самом деле не является, это **set**.

В то время, как _microtask queue_ - действительно очередь.

Дело в том, что на очередной итерации, в _task queue_ может находиться множество задач в разных статусах. Алгоритм _queue_ предполагает изъятие из очереди первого элемента (_dequeue_). Однако, в случае с _task queue_ первый элемент не обязательно является _runnable task_ в данный момент. **Процесс, вместо _dequeue_ должен найти первую задачу в статусе _runnable task_ и извлечь её из набора**, что нельзя считать реализацией алгоритма _queue_.

Микротаски же, наоборот находятся в очереди и выводятся из неё в том порядке, в котором они в очередь попали.

Синхронный код с самого начала своего исполнения уже находится внутри Event loop в виде задачи.

## Что еще попадает в task queue:

**События** - отправка события часто попадает в task queue, но не всегда. Есть много событий, отправка которых осуществляется в других задачах. Например, события MouseEvent и KeyboardEvent могут быть объеденены в одну задачу, source которой ассоциирован с user interaction task source

**Парсинг** - HTML parser токенизирует один или несколько байт, потом обрабатывает полученный токенизированный результат

**Колбэки** - как правило, попадают в task queue, это же относится и к классическому примеру setTimeout(() => {}), в данном случае в setTimeout передается колбэк, который встанет отдельной задачей в task queue

**Запрос ресурсов** - в случае не блокируемой загрузки ресурса (например, изображения), ставится отдельная задача в task queue

**Манипуляции с DOM** - некоторые элементы генерируют задачу в task queue в ответ на манипуляции с DOM. Как пример, вставка нового элемента в DOM спровоцирует постановку задачи на перерисовку родительского элемента.

В случае с task queue, работа по определению и добавлению задач в очередь лежит на плечах агента.

## Работа c microtask queue

\- это, своего рода опция, доступная задаче во время исполнения через Web API, что позволяет данной конкретной задаче реализовать какие-либо свои собственные асинхронные потребности. Технически, каждая задача, будь то исполнение JS-кода, токенизация HTML текста, события ввода-вывода или что-либо еще, может использовать microtask queue для реализации своих собственных целей.

Если говорить конкретно о JavaScript, язык, в своей реализации, предполагает наличие собственных асинхронных операций - **Promise**, для разрешния которых используется microtask queue.

[Источник](https://habr.com/ru/articles/789572/)

Когда промис переходит в состояние «выполнено» (fulfilled) или «отклонено» (rejected), соответствующие обработчики .then() или .catch() добавляются в очередь микрозадач.

async/await также основаны на микрозадачах. Когда функция объявлена как async, она автоматически возвращает промис. await заставляет JS ожидать решения промиса, добавляя оставшуюся часть функции как микрозадачу.
