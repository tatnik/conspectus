# Новое в версии 18.

Самое существенное обновление, которое появилось в React 18, — **конкурентный режим** (_Concurrent Mode_). Это новый механизм, с помощью которого можно готовить несколько версий пользовательского интерфейса одновременно. Он предназначен для улучшения производительности и быстродействия приложений, особенно в случаях, когда рендеринг компонентов занимает много времени. В своей внутренней реализации React в этом режиме использует сложные приёмы, такие, как приоритетные очереди и многократная буферизация.

В конкурентном режиме React может прерывать, приостанавливать, возобновлять или прекращать рендеринг. Он работает путём разбиения длинных операций на более короткие и выполняет их по частям. Это даёт возможность браузеру не блокироваться и продолжать отображать пользовательский интерфейс даже во время выполнения длительных операций.

Для использования конкурентного режима нужно создать корневой компонент с флагом concurrent: true и использовать хук useTransition() или функцию lazy()

```js
import { createRoot } from 'react-dom';

const root = document.getElementById('root');

createRoot(root, { concurrent: true }).render(<App />);
```

[Подробнее...](https://vk.com/@habr-react-18-chto-pomenyalos)

## Автоматический батчинг setState

В React 17 только React события будут обрабатываться пакетно, а нативные JavaScript события, промисы, setTimeout и setInterval обрабатываться не будут. В React 18 все события обрабатываются пакетно.

React будет собирать все обновления состояний, произошедшие во время выполнения асинхронной операции, и применять их одним общим обновлением.
Это избавляет от множественных перерисовок компонентов и улучшает производительность приложения. Для использования автоматического батчинга нужно использовать функции setState() или useReducer() внутри асинхронных операций, таких, как setTimeout() или fetch().

## Прекращение поддержки IE

## flushSync

Используется, чтобы заставить React сбросить всю ожидающую работу и синхронно обновить DOM.
Он может быть полезен при интеграции со сторонним кодом, например, с API браузеров.

## Возвращаемое значение React компонента

В React 17 для возврата пустого компонента можно использовать только null, а явное возвращение undefined вызовет ошибку. В React 18 поддерживается возврат null и undefined

## Улучшения SSR (server side rendering)

### Предварительный рендеринг на сервере

позволяет рендерить компоненты на сервере до того, как они будут отображены на клиенте.

Это может значительно сократить время загрузки страницы и улучшить SEO.

Для использования предварительного рендеринга в React 18 можено использовать новый метод — renderToNodeStream()

### Использование Suspense

Можно использовать Suspense для ожидания загрузки данных на сервере и отображения заглушки до того, как данные будут доступны.

## Новые хуки

### **useOpaqueIdentifier**

создаёт уникальные идентификаторы на сервере и клиенте. Это может быть полезно для SSR, когда необходимо генерировать уникальные идентификаторы на сервере для последующего использования на клиенте.

### **useId**

помогает создавать уникальные идентификаторы на сервере и клиенте для элементов DOM. Это может быть полезно, когда необходимы уникальные идентификаторы для элементов, которые будут использоваться в качестве ссылок, для обработки событий, при работе с формами.

### **useSyncExternalStore**

позволяет синхронизировать состояние компонента с внешним хранилищем данных. Это может быть полезно, когда необходимо обмениваться данными между компонентами или с другими приложениями.

### **useInsertionEffect**

даёт возможность выполнять эффекты после монтирования компонента, но до его рендеринга.

### **useDeferredValue**

с его помощью можно отложить обновление состояния компонента до момента, когда это необходимо. Это может быть полезно для улучшения производительности и предотвращения лишних перерисовок компонентов.

Для использования useDeferredValue нужно передать ему значение состояния и опцию timeoutMs, чтобы задать время задержки перед обновлением значения.

Хук useDeferredValue работает путём создания отложенной версии значения состояния компонента. Эта отложенная версия будет использоваться вместо реального значения во время рендеринга компонента, пока не наступит момент, когда значение должно быть обновлено.

Когда это происходит, React сравнивает реальное значение с отложенной версией, и, если они отличаются, происходит обновление компонента.

используем useDeferredValue с useState(). В этом случае мы откладываем обновление состояния до момента, когда пользователь закончит вводить текст в поле ввода:

```js
function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text, { timeoutMs: 1000 });

  function handleChange(event) {
    setText(event.target.value);
  }

  return (
    <div>
      <input
        type="text"
        value={text}
        onChange={handleChange}
      />
      <div>Deferred text: {deferredText}</div>
    </div>
  );
}
```

[Подробнее...](https://reactdev.ru/reference/react/useDeferredValue/#indicating-that-the-content-is-stale)
