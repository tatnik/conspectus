# Функции в JS

## Детерминированные и недетерминированные

**Детерминированные** функции для одних и тех же входных данных всегда выдают один и тот же результат.

Примеры: функции в математике, _console.log()_.

**Недетерминированные** функции возвращают разные значения для одних и тех же входных данных.

Примеры: _Math.random()_, _Date.now()_, функции, оперирующие системным временем.

Функция может стать _недетерминированной_, если она обращается не только к своим аргументам, но и некоторым внешним данным, например глобальным переменным, переменным окружения и так далее.

## Побочные эффекты

- это любые взаимодействия с внешней средой ( файловые операции, такие как запись в файл, чтение файла, отправка или приём данных по сети, вывод в консоль).

- изменения внешних переменных (например, глобальных) и входных параметров в случае, когда они передаются по ссылке.

- обработка исключительных ситуаций

Побочные эффекты могут усложнять код, приводить к ошибкам.

Хорошая практика - изолировать побочные эффекты в небольшой части приложения.

## Чистая функция

\- это детерминированная функция, которая не производит побочных эффектов. Такая функция зависит только от своих входных аргументов и всегда ведёт себя предсказуемо.

## Плюсы чистых функций:

- Их просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.

- Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.

- Их легко комбинировать, получая новое поведение без необходимости переписывать программу.

## Command-query Separation (CQS):

\- каждая функция должна быть либо командой (выполняет действие), либо запросом (извлекает данные), но не обоими одновременно.

**Команда** - функция, связанная с выполнением побочных эффектов, возвращает результат успешности выполнения (например, true/false).

**Запрос** не изменяет состояние системы, возвращает ответ на заданный вопрос.

Цель разделения: изолировать чистый код от кода с эффектами, упростить понимание и поддержку кода.

При невозможности соблюдения CQS, необходимо явно показывать намерение функции (например, именовать ее как команду).

## Функции с переменным количеством аргументов (rest-оператор)

Rest-оператор **(...)** позволяет создавать функции с переменным числом аргументов, обрабатывая их как массив.

Это удобно для случаев, когда необходимо работать с разным количеством параметров без явного перечисления каждого из них.

Он может использоваться только для последнего параметра функции.

```js
const func = (a, b, ...params) => {
  ...
  //a, b - фиксируем два первых аргумента
  // в массив params помещаются все оставшиеся аргументы
}
```

## Spread-оператор

используется при вызове функций. Он извлекает элементы из массива и заполняет ими параметры функции при вызове.

В отличие от _rest-оператора_ в определении функций, _spread-оператор_ не обязательно должен быть последним, он может располагаться в любой позиции. spread-операторов может быть несколько:

```js
sum(8, ...numbers1, 10, ...numbers2);
```

## Функции высшего порядка

\- это функции, которые либо принимают, либо возвращают другие функции, либо делают всё сразу. Такие функции, как правило, реализуют некий обобщённый алгоритм (например, сортировку), а ключевую часть логики делегируют программисту через дополнительную функцию. Главный плюс от применения такого подхода — сокращение дублирования.

`elements.sort([compareFunction])`

принимает необязательный параметр _compareFunction()_ — функцию, которая указывает, как сортировать данный массив

```js
const users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

// Функция принимает на вход сравниваемые элементы массива
const compare = (a, b) => {
  if (a.age === b.age) {
    return 0;
  }

  return a.age > b.age ? 1 : -1;
};

users.sort(compare);
```

функция _compare_ принимает на вход два параметра — _sort()_ отдаёт в неё два элемента, которые она сравнивает в данный момент. Ели элементы равны, то нужно вернуть 0, если первый элемент больше второго, то считается, что они отсортированы неправильно, и возвращается 1, иначе возвращается -1, а _sort()_ производит их сортировку.

функция _compare_ вызывается внутри _sort()_ множество раз (а именно на каждое сравнение). Как только она начнёт возвращать -1 для каждой пары элементов — сортировка завершена.

## Объекты первого класса

\- элементы, которые могут быть переданы как параметр, возвращены из функции или присвоены переменной. Другими словами, речь идет обо всем, что может быть данными. Самые простые типы данных — это числа и строки. Все остальные типы данных также являются объектами первого класса.

функция — тоже данные, ведь ее можно присвоить константе.
Определение функции — это выражение, а значит оно возвращает значение, а именно — функцию. А раз определение функции — выражение, возвращающее функцию, то мы можем
попробовать вызвать ее без создания промежуточной константы:

```js
// Определяем функцию (v) => v и тут же вызываем ее
((v) => v)('run'); // run
```

Скобки вокруг определения функции они используются с той же целью, что и в арифметических операциях — для группировки.

## Лексическое окружение

При вызове функции интерпретатор создает специфический словарь, в который помещает все аргументы, переменные, константы и функции, используемые в вызываемой функции. Это и есть лексическое окружение, привязанное к вызванной функции.

В процессе выполнения функции значения переменных могут меняться, что сразу же отражается в лексическом окружении. После выполнения функции ее лексическое окружение уничтожается, а занятая им память освобождается.

Окружение есть не только у функций. Любой идентификатор, определенный на уровне модуля, попадает в лексическое окружение модуля. Кроме того, существует и глобальное окружение.

В процессе работы интерпретатор производит поиск значения идентификатора сначала в локальном лексическом окружении (в том, где используется идентификатор), затем во внешнем окружении, вплоть до уровня модуля, а затем и до глобального уровня.

Внешним окружением по отношению к функции считается окружение, в котором функция была объявлена (а не вызвана!).

## Частичное применение функций

\- это техника, которая позволяет создавать новые функции на основе уже существующих, частично применяя аргументы.

это можно реализовать, например, с помощью дополнительной функции partialApply, которая принимает исходную функцию и параметры для применения.

```js
const partialApply = (fn, arg2) => (arg1) => fn(arg1, arg2);
// второй аргумент имеет фиксированное значение

const pow = (a, b) => a ** b;
const f1 = partialApply(pow, 2);
f1(1); // 1
f1(10); // 100
```

## Каррирование

\- это процесс превращения функции от n аргументов в цепочку вложенных n-функций от одного аргумента. Соответственно, каррированная функция — это множество функций от одного аргумента.

Предположим, что у нас есть функция `const sum = (a, b, c) => a + b + c`, которая складывает три числа. Тогда ее каррированная версия будет выглядеть так: `const sum2 = a => b => c => a + b + c`, а использование таким: `sum2(5)(10)(-2)`

Для каррирования существующую функцию без ее реализации создается цепочка вложенных функций, в которой количество вложений равно количеству аргументов исходной функции и в конце которой происходит вызов оригинальной функции: ` const sum2 = a => b => c => originalSum(a, b, c)`
