# Многопоточность и мультипроцессорность

**Многопоточность** — выполнение нескольких потоков (flows of execution) внутри одного процесса.  
**Мультипроцессорность** — запуск нескольких независимых процессов, каждый со своим интерпретатором Python и памятью.

Эти подходы используются для повышения производительности, асинхронной работы, параллельных вычислений и увеличения отзывчивости программ.

---

## Потоки (модуль `threading`)

- **Поток (thread)** — минимальная единица выполнения, разделяющая память с другими потоками в том же процессе.
- В Python стандартная многопоточность реализована через модуль `threading`.
- **GIL (Global Interpreter Lock)** — глобальная блокировка интерпретатора, которая не позволяет выполнять байткод нескольким потокам одновременно (ограничивает настоящую параллельность для CPU-bound задач, но не мешает I/O-bound).

### Пример создания и запуска потока:

```python
import threading

def worker(num):
    print(f"Поток {num} стартовал")

threads = []
for i in range(3):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
print("Все потоки завершились")
```

- Для синхронизации потоков используются примитивы: `Lock`, `RLock`, `Semaphore`, `Event`, `Condition`.

```python
lock = threading.Lock()

def safe_worker():
    with lock:
        # Критическая секция
        pass
```

---

## Процессы (`multiprocessing`)

- **Процесс** — отдельный экземпляр интерпретатора Python, своя память, своё пространство данных.
- Реализуется с помощью модуля `multiprocessing`.
- Подходит для вычислительно сложных задач, т.к. GIL не распространяется на разные процессы.
- Каждый процесс "изолирован", объекты не делятся напрямую, для обмена используются очереди, пайпы и менеджеры.

### Пример создания и запуска процесса:

```python
from multiprocessing import Process

def worker(num):
    print(f"Процесс {num} стартовал")

if __name__ == "__main__":
    processes = []
    for i in range(3):
        p = Process(target=worker, args=(i,))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()
    print("Все процессы завершились")
```

---

## Очереди и синхронизация

### Очереди (`Queue`)

- Для обмена данными между потоками: `queue.Queue`
- Для обмена между процессами: `multiprocessing.Queue`
- Очередь гарантирует потокобезопасный обмен данными (FIFO).

```python
import queue
q = queue.Queue()
q.put("item")
item = q.get()
```

```python
from multiprocessing import Queue
q = Queue()
q.put("item")
print(q.get())
```

### Синхронизация

- **Потоки**: используйте примитивы из `threading` (Lock, RLock, Event, Semaphore, Condition)
- **Процессы**: аналогичные примитивы (`multiprocessing.Lock`, `multiprocessing.Event`, и др.)

---

## Интересные детали и фишки

- Многопоточность подходит для задач, связанных с ожиданием ввода-вывода (сетевые запросы, работа с файлами).
- Мультипроцессорность — для вычислительно тяжёлых задач (обработка больших данных, параллельные вычисления).
- Передача сложных объектов между процессами может быть медленной (используется сериализация через pickle).
- В потоках нельзя “убить” поток принудительно — только мягко завершать через флаги.
- Модуль `concurrent.futures` упрощает параллелизм: есть `ThreadPoolExecutor` и `ProcessPoolExecutor`.
- Некоторые сторонние библиотеки (например, `joblib`, `pathos`) упрощают работу с параллелизмом и позволяют обойти ограничения pickle.

---

## Типичные ошибки и подводные камни

- Проблемы гонки данных: два потока (или процесса) изменяют один и тот же объект без синхронизации.
- Зависание из-за неправильного использования блокировок (deadlock).
- Забыли вызвать `join()` для потоков/процессов — программа завершится до выполнения всех задач.
- Использование потоков для CPU-bound задач в Python обычно не ускоряет выполнение из-за GIL.
- Передача не сериализуемых объектов в процессы (`multiprocessing`) вызывает ошибки.

---

## Ссылки на документацию и полезные ресурсы

- [threading — Управление потоками](https://docs.python.org/3/library/threading.html)
- [multiprocessing — Многопроцессорная обработка](https://docs.python.org/3/library/multiprocessing.html)
- [queue — Очереди для обмена между потоками](https://docs.python.org/3/library/queue.html)
- [concurrent.futures — Упрощённые высокоуровневые API для параллелизма](https://docs.python.org/3/library/concurrent.futures.html)
