# Внешние библиотеки Python: подробный обзор

---

## 1. **requests** — HTTP-клиент

- Для работы с интернет-запросами (HTTP/HTTPS).
- Простая отправка GET, POST, PUT, DELETE-запросов.

**Примеры использования:**

```python
import requests

r = requests.get('https://api.github.com')
print(r.status_code)     # Код ответа
print(r.text)            # Текст ответа
print(r.json())          # Данные в формате JSON (если возможно)
```

**Популярные функции и методы:**

| Функция/метод          | Описание                            |
| ---------------------- | ----------------------------------- |
| `requests.get(url)`    | GET-запрос                          |
| `requests.post(url)`   | POST-запрос                         |
| `requests.put(url)`    | PUT-запрос                          |
| `requests.delete(url)` | DELETE-запрос                       |
| `r.status_code`        | HTTP-код ответа (200, 404, и т.д.)  |
| `r.text`               | Ответ как строка                    |
| `r.json()`             | Ответ как JSON (словарь)            |
| `r.content`            | Ответ как bytes                     |
| `r.headers`            | Словарь HTTP-заголовков             |
| `r.cookies`            | Cookies                             |
| `r.raise_for_status()` | Бросить ошибку при неудачном ответе |
| `requests.params`      | Параметры запроса (словарь)         |
| `requests.timeout`     | Таймаут                             |

**Документация:**  
https://docs.python-requests.org/

---

## 2. **matplotlib** — визуализация данных

- Гибкая библиотека для построения графиков, диаграмм и визуализаций.

**Пример построения графика:**

```python
import matplotlib.pyplot as plt

x = [1, 2, 3, 4]
y = [2, 4, 6, 8]
plt.plot(x, y, label='Линия')
plt.xlabel('ось X')
plt.ylabel('ось Y')
plt.title('Мой первый график')
plt.legend()
plt.show()
```

**Основные функции и методы:**

| Функция/метод   | Описание                 |
| --------------- | ------------------------ |
| `plt.plot()`    | Линейный график          |
| `plt.scatter()` | Точечный график          |
| `plt.bar()`     | Столбчатая диаграмма     |
| `plt.hist()`    | Гистограмма              |
| `plt.pie()`     | Круговая диаграмма       |
| `plt.xlabel()`  | Подпись оси X            |
| `plt.ylabel()`  | Подпись оси Y            |
| `plt.title()`   | Заголовок                |
| `plt.legend()`  | Легенда                  |
| `plt.grid()`    | Сетка                    |
| `plt.savefig()` | Сохранить график в файл  |
| `plt.show()`    | Показать окно с графиком |

**Документация:**  
https://matplotlib.org/stable/contents.html

---

## 3. **pandas** — обработка таблиц и анализ данных

- Работа с табличными данными, импорт из CSV/Excel, фильтрация, агрегация.

**Пример работы:**

```python
import pandas as pd

df = pd.read_csv('data.csv')
print(df.head())         # Показать первые строки
print(df.describe())     # Основная статистика
```

**Ключевые объекты:**

- `DataFrame` — таблица данных (строки и столбцы)
- `Series` — отдельная колонка (или 1D массив)

**Часто используемые методы:**

| Функция/метод           | Описание                             |
| ----------------------- | ------------------------------------ |
| `pd.read_csv()`         | Чтение CSV-файла                     |
| `pd.read_excel()`       | Чтение Excel-файла                   |
| `df.head()`             | Первые строки таблицы                |
| `df.tail()`             | Последние строки таблицы             |
| `df.info()`             | Информация о таблице                 |
| `df.describe()`         | Статистика по числовым столбцам      |
| `df['col']`             | Доступ к столбцу                     |
| `df.loc[]`, `df.iloc[]` | Индексация по строкам/столбцам       |
| `df.drop()`             | Удаление строк или столбцов          |
| `df.sort_values()`      | Сортировка                           |
| `df.groupby()`          | Группировка                          |
| `df.apply()`            | Применение функции ко всем значениям |
| `df.to_csv()`           | Сохранение в CSV-файл                |

**Документация:**  
https://pandas.pydata.org/pandas-docs/stable/

## NumPy: назначение и основной функционал

- **NumPy** (Numerical Python) — это основная библиотека для научных и инженерных вычислений в Python.
- Обеспечивает удобную работу с **массивами** (ndarray) и матрицами, поддерживает множество математических операций.

---

### Зачем нужен NumPy?

- Быстрое и эффективное хранение, обработка и вычисления с **большими объемами числовых данных**.
- Реализация математических, статистических и алгебраических операций "на лету" — **намного быстрее обычных списков** Python.
- Является фундаментом для других библиотек (Pandas, SciPy, scikit-learn, TensorFlow и др.).

---

### Ключевые возможности

#### 1. **Массивы (ndarray)**

- Однородные (все элементы одного типа), многомерные.

```jsx
import numpy as np
a = np.array([1, 2, 3])
b = np.array([[1, 2], [3, 4]])
```

#### 2. **Быстрая арифметика и операции над массивами**

```jsx
a = np.array([1, 2, 3])
b = np.array([10, 20, 30])
print(a + b)      # [11 22 33]
print(a * 2)      # [2 4 6]
print(a ** 2)     # [1 4 9]
```

#### 3. **Векторизация**

- Операции применяются ко всем элементам сразу, без циклов.

#### 4. **Матричные операции**

```jsx
A = np.array([[1, 2], [3, 4]])
B = np.array([[2, 0], [1, 3]])
print(A @ B)      # Матрица-произведение
```

#### 5. **Генерация массивов**

```jsx
zeros = np.zeros((3, 3))        # 3x3 из нулей
ones = np.ones(5)               # Вектор из единиц
rng = np.arange(0, 10, 2)       # [0 2 4 6 8]
rand = np.random.rand(2, 2)     # 2x2 случайных от 0 до 1
```

#### 6. **Статистические функции**

```jsx
data = np.array([1, 2, 3, 4])
print(data.mean())   # 2.5
print(data.std())    # стандартное отклонение
print(data.sum())    # сумма элементов
```

#### 7. **Срезы и индексация**

```jsx
a = np.array([1, 2, 3, 4, 5])
print(a[1:4])      # [2 3 4]
```

#### 8. **Работа с многомерными данными**

```jsx
matrix = np.array([[1, 2, 3], [4, 5, 6]])
print(matrix.shape)     # (2, 3)
print(matrix.T)         # Транспонирование
```

---

### Почему NumPy быстрее обычных списков?

- Использует массивы низкоуровневого типа (C), а не объекты Python.
- Операции реализованы на уровне компилируемого кода.
- Минимизирует необходимость циклов на Python — всё происходит "векторно".

---
