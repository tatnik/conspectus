# GIT - распределенная система контроля версий

## .gitignore

текстовый файл в корне проекта со списком шаблонов

файл, соответствующий хотя бы одному шаблону, будет игнорироваться гитом

`git status --ignored ` список всех игнорируемых файлов

## Хеширование коммитов

Информация о коммите — это набор данных:

- когда был сделан коммит,
- содержимое файлов в репозитории на момент коммита
- ссылка на предыдущий, или родительский коммит

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1
(_Secure Hash Algorithm_ — безопасный алгоритм хеширования)
и получает для каждого коммита свой уникальный **хеш**— результат хеширования.
Обычно это короткая (40 символов в случае SHA-1) строка,
которая состоит из цифр 0—90—9 и латинских букв A—FA—F (неважно, заглавных или строчных).

Она обладает следующими важными свойствами:

- если хеш получить дважды для одного и того же набора входных данных,
  то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ),
  то хеш тоже изменится (причём сильно).

**Хеш**— основной идентификатор коммита,
он позволяет узнать автора, дату и содержимое закоммиченных файлов,
его можно передавать различным git-командам в качестве параметра.

Все хеши, а также таблицу соответствий **хеш**→ _информация о коммите_ Git хранит в папке .git

В числе прочих файлов в папке .git есть служебный файл **HEAD**. Он указывает на самый свежий коммит.
Если надо передать хеш последнего коммита в качестве параметра можно написать слово _HEAD_

## Статусы файлов

- Статусом **untracked** помечается файл, о существовании которого Git знает, но не следит за изменениями в нём.
  Этот статус — противоположность **tracked**, в который попадают все файлы, отслеживаемые Git.
- Файл переходит в статус **staged** после выполнения _git add_.
- Статус **modified** означает, что файл был изменён.

```bash
  mermaid
graph LR;
  A[untracked];
  B[staged/tracked];
  C[tracked];
  D[modified];
  A -- "git add" --> B;
  D -- "git add" --> B;
  B -- "git commit" --> C;
  B -- "изменения" --> D;
  C -- "изменения" --> D;
```

## Основные команды Git

- **инициализация git-репозитория**

`git init` В текущей папке создается скрытая подпапка .git, где будет храниться вся служебная информация.
Если эту подпапку удалить, текущая папка перестанет быть "загитченой"

- **клонирование чужого репозитория**

`git clone АККАУНТ/URL`

- **текущее состояние репозитория**

`git status`

- **подготовка к сохранению**

`git add ` маркирует файлы как отслеживаемые и фиксирует содержимое указанных файлов для последующего сохранения их в репозитории

`git add --all ` подготовить к сохранению все файлы проекта

`git add todo.txt ` подготовить к сохранению файл todo.txt

`git add . ` подготовить к сохранению всю текущую папку

- **сохранение файлов в репозитории**

`git commit` сохраняются все ранее подготовленные файлы
в репозиторий переносится то содержимое файлов, которое было актуально на момент выполнения команды _git add_

`git commit -m "Здесь должно быть название коммита" `

- **история коммитов**

`git log` по умолчанию коммиты выводятся в обратном хронологическом порядке

`git log main..feature`
коммиты, которые есть в ветке _feature_, но отсутствуют в _master_

`git log main...feature`
коммиты, которые есть в одной из веток, но не в обеих сразу

![сравнение веток](/jpg/git-log.jpg 'сравнение веток')

`git log --oneline` вывод в сжатом формате - часть хеша и название коммита

`git log -p [-<number>]` показывает разницу для каждого коммита, количество коммитов можно ограничить доп.параметром

Еще опции:

`--stat` -+статистика измененных файлов для каждого коммита

`--name-only` + список измененных файлов

`--name-status` + список файлов, которые были добавлены/изменены/удалены

`--graph` - ASCII граф с ветвлениями и историей слияний

`--pretty=<format>` - показ в альтернативном формате (oneline, short, full, fuller или format (с указанием своего формата))

`--no-merges` не показывать коммиты слияния

`--since, --after` только коммиты после указанной даты

`--until, --before` коммиты до даты

`--grep` коммиты, сообщение которых содержит указанную строку

[Подробнее...](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2#r_viewing_history)

- **просмотр коммита**

`git show <commit>`

`git show <commit>^` просмотр родителя коммита

`git show <commit>~[n]` просмотр n-го предка коммита

- **сравнение версий**

`git diff ` сравнит последнюю закоммиченную версию файла с той, что находится в состоянии _modified_.

`git diff --staged ` покажет изменения в staged-файлах относительно последних закоммиченных версий

`git diff <коммит1> <коммит2> ` сравнит два коммита, показав список инструкций: как превратить состояние <коммит1> в состояние <коммит2>

## Отмена изменений

- **git restore**

`git restore <file> ` откат файла до последней сохранённой (в коммите или в staging) версии

`git restore --staged <file> ` статус файла вернется в состояние modified или untracked

- **git reset**

Только для локальной истории!

`git reset --soft <commit hash> ` мягкий откат истории до коммита с хешем <hash>. Происходит только сброс дерева коммитов, не затрагивая дерева проиндексированных файлов и дерева рабочих файлов.

`git reset --mixed <commit hash> ` смешанный откат. Это режим работы по умолчанию. Сброс дерева коммитов и дерева проиндексированных файлов. Рабочие файлы не меняются.

`git reset --hard <commit hash> ` жесткий откат. Более поздние коммиты потеряются. Рабочие файлы возвращаются к состоянию указанного коммита!

## Изменение коммита

`git commit --amend --no-edit ` Дополнит последний коммит новыми файлами, сообщение не изменится

`git commit --amend -m "Обновлённое сообщение коммита" ` Изменит только сообщение

можно изменить любой коммит локальной истории, предварительно выполнив rebase на этот коммит, подробности ниже по ссылке

[Перезапись локальной истории коммитов](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8#r_rewriting_history)

## Сторнирование коммита

`git revert` создает новый коммит, который вносит изменения, противоположные изменяемому коммиту

## Перемещение коммитов по истории (только для локального репозитория, до push-а)

Можно предварительно назначить редактор, который будет использоваться,
например VSCode: `git config --global core.editor "code --wait"`

Запустить интерактивное перемещение : `git rebase -i HEAD~N`, N-количество коммитов, которые будут доступны в редакторе.

Далее изменить порядок коммитов, сохранить (Ctrl+S) и закрыть окно редактора.

Если в процессе возникнут конфликты — git покажет их, нужно будет решить и продолжить rebase командой `git rebase --continue`.

Если что-то пошло не так, всегда можно отменить ребейз: `git rebase --abort`

## Работа с ветками

- **создание веток**

`git branch feature/the-finest-branch` создание ветку от текущей с названием feature/the-finest-branch;

`git checkout -b feature/the-finest-branch` создание ветку feature/the-finest-branch и сразу переключение на неё.

- **навигация по веткам**

`git branch ` показ веток репозитория (текущая ветка будет отмечена символом \*);

`git checkout feature/br` переключение на ветку feature/br.

- **сравнение веток**

`git diff main HEAD ` разница между веткой main и указателем на HEAD;

`git diff HEAD~2 HEAD ` разница между тем коммитом, который был два коммита назад, и текущим.

![Сравнение веток](/jpg/git-diff.jpg 'Cравнение веток)

- **удаление веток**

`git branch -d br-name ` удаление ветки br-name, но только если она является частью main;

`git branch -D br-name ` удаление ветки br-name, даже если она не объединена с main.

- **слияние веток**

`git merge main ` объединение ветку main с текущей активной веткой.

- **копирование коммитов из одной ветки в другую**

`git cherry-pick <commit1>`,
`git cherry-pick <commit1> <commit2> <commit3>`, - применить выбранные коммиты к текущей ветке

`git cherry-pick <commit-start>..<commit-end>` - использовать диапазон коммитов, <commit-start> не включается в диапазон
для его включения необходимо в качестве начала диапазона указать родителя:
`git cherry-pick <commit-start>^..<commit-end>` или `git cherry-pick <commit-start>~..<commit-end>`

[Подробнее...](https://www.dev-notes.ru/articles/git/demystifying-git-cherry-pick/)

## Работа с удаленным репозиторием

- **привязка удалённого репозитория к локальному**

`git remote add` команде необходимо передать два параметра: имя удалённого репозитория и его URL.

`git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git `

_предварительно на компьютере должны быть сгенерированы ssh-ключи_
_и публичный ключ указан в настройках удаленного репозитория_
[Как сгенерировать ssh-ключи](https://practicum.yandex.ru/trainer/git-basics/lesson/19d174db-bd33-4307-a8e7-61b749a1639c/)

- **проверка, что репозитории связаны**

```bash
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```

- **отправка изменений в удалённый репозиторий**

`git push`
В первый раз эту команду нужно вызвать с флагом _-u_ и параметрами _origin_ (имя удалённого репозитория)
и _main_ или _master_ (название текущей ветки).
Флаг _-u_ свяжет локальную ветку с одноимённой удалённой.

`git push -u origin main ` Если команда приведёт к ошибке, заменить main на master.

флаг `-u` это сокращение для `--set-upstream`. В дальнейшем при работе с удалённым репозиторием флаг _-u_ можно опустить и писать просто _git push_.

`git push -u origin my-branch ` отправка новой ветки my-branch в удалённый репозиторий и привязка локальной ветки к удалённой, чтобы при дополнительных коммитах можно было писать просто git push без -u;

`git push -u origin my-branch:repo-branch ` отправка локальной ветки my-branch в удалённый репозиторий в ветку repo-branch и привязка веток

`git push my-branch ` отправка изменений в ветку my-branch, которая уже существует в удалённом репозитории;

- **получение изменений из удаленного репозитория**

`git pull ` получение изменений текущей ветки из удалённого репозитория.

`git fetch origin` получение изменений из удаленного репозитория (без автоматического слияния с ветками локального репозитория)

## Участие в публичном проекте

- необходимо склонировать основной репозиторий, создать тематическую ветку для работы

```
$ git clone <url>
$ cd project
$ git checkout -b featureA
  ... work ...
$ git commit
  ... work ...
$ git commit
```

- после завершения работы с тематической веткой сделать Fork исходного проекта
- добавить URL на созданный проект как второй удаленный репозиторий

`$ git remote add myfork <url>`

- отправить в него тематическую ветку

`$ git push -u myfork featureA`

- отправить в исходный проект запрос на слияние

`$ git request-pull origin/master myfork`

[Подробнее...](https://git-scm.com/book/ru/v2/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B9-Git-%D0%A3%D1%87%D0%B0%D1%81%D1%82%D0%B8%D0%B5-%D0%B2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B5)

## Интерактивное индексирование

```
$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now>
```

позволяет управлять процессом индескирования файлов, включая/исключая в коммиты отдельные файлы или части файлов

[Подробнее...](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5#r_interactive_staging)

## Припрятывание изменений

- **спрятать текущие изменения в тайник**

`git stash push` или `git stash`

`git stash --keep-index` + оставить изменения в индексе

`git stash --include-untracked` или `git stash -u` - припрятать также созданные неотслеживаемые файлы (кроме тех, которые указаны в игнорируемых)

`git stash --all` или ``git stash -a` - прятать все, включая игнорируемые файлы

- **список тайников**

`git stash list`

- **содержимое тайника**

`git stash show [stash-name]`

- **достать изменения из тайника**

`git stash apply [stash-name]`

`git stash show [stash-name] --index` - с восстановлением изменений в индексе

все припрятанное по-прежнему останется в тайнике

- **достать изменения из тайника и удалить тайник**

`git stash pop [stash-name]`

- **создать ветку из тайника и удалить тайник**

`git stash branch <branch-name>` - ветка будет создана на основе того коммита, который был последним перед созданием тайника

## Очистка рабочего каталога

- **удалить неотслеживаемые и неигнорируемые файлы**

`git clean`

`git clean -n` показать все файлы, которые будут удалены (без удаления)

`git clean -d` удалять также каталоги

`git clean -x` удалять также игнорируемые

`git clean -f` форсировать удаление

`git clean -i` удаление в интерактивном режиме

[Подробнее...](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D1%80%D0%B8%D0%BF%D1%80%D1%8F%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D0%BE%D1%87%D0%B8%D1%81%D1%82%D0%BA%D0%B0)

## Прочее

[Работа с тэгами](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%82%D0%B5%D0%B3%D0%B0%D0%BC%D0%B8)

[Псевдонимы](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B-%D0%B2-Git)

[Перебазирование](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%B1%D0%B0%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

[Выбор ревизии](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%92%D1%8B%D0%B1%D0%BE%D1%80-%D1%80%D0%B5%D0%B2%D0%B8%D0%B7%D0%B8%D0%B8#r_revision_selection)

[Продвинутое слияние](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D1%80%D0%BE%D0%B4%D0%B2%D0%B8%D0%BD%D1%83%D1%82%D0%BE%D0%B5-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5#r_manual_remerge)

## Стратегии ветвления

### GitHub Flow

![github-flow](/conspectus/jpg/github-flow.jpg)

[Правила](https://githubflow.github.io/)

### Git Flow

![git-flow](/conspectus/jpg/git-flow.jpg)

### The Forking Workflow

![forking-workflow](/conspectus/jpg/forking-workflow.jpg)

[Подробнее о стратегиях](https://javarush.com/groups/posts/2693-komandnaja-rabota-bez-putanicih-razbiraem-strategii-vetvlenija-v-gite)
